# 使用说明
*版本说明：*
*python:3.8.10*
*onnx版本：1.11.0*
1. 处理数据集：
* 将数据集命名为zjb_photos并放入 your/path/to/华南虎视觉感知任务/任务3.6/装甲板数字数据集 路径下
* 按照要求中红蓝装甲板图片数量一样的要求，手动对六个数据集文件（012345）进行分类，按照红蓝装甲板的不同分成12个文件；运行dataset.py文件，得到val和train数据集，再手动将val和train数据集中同一类别的红蓝装甲板图片合成一个文件。
![数据集格式图片](https://img-blog.csdnimg.cn/ed82c3544ec54541a8ca697203b8e3e6.png)


2. 运行train.py文件
效果图：
![训练效果图](https://img-blog.csdnimg.cn/f60f8c78ecba42e5aa48f473156a024d.png)

3. 运行predict.py文件得到网络的pth文件模型
4. 运行getOnnx.py文件得到网络的onnx文件模型
5. 在c++上进行部署，打开arrange文件
（1）在vscode上运行：
将需要预测的图片和onnx文件放在arrange/build文件夹下，并在arrange/main.cpp里修改放入图片的名称,然后运行
![预测结果图1](https://img-blog.csdnimg.cn/a8f4f672fa9049d5a3ef0a5b73f2a104.png)

（2）在终端运行：
将需要预测的图片放在arrange/build文件夹下，并在arrange/main.cpp里修改放入图片的名称
在arrange文件夹下打开终端，输入以下命令：
```
mkdir build
cd build
cmake ..
make
./Test

```
(3)部署效果图片：
![预测结构图2](https://img-blog.csdnimg.cn/1fdd9a8e0cdc40d1b58ce776b5d506c2.png)




# 思路
1. 在dataset.py文件里面可以将数据集按照4：1的比例分为训练集和验证集
2. 网络是一个全连接层，输入80 * 80 * 3的图片，输出6个索引值。最高的索引值对应的类别就是图片的类别。
3. 训练过程：
* 将图片导入并且转换成80 * 80 * 3的张量
* 实例化网络
  定义损失函数（交叉熵损失函数，先进行sigmoid函数，再将结果放在传统的交叉熵函数中进行计算）
  定义优化器 optim.Adam（它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。它的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳）
  定义训练轮数
  补充：梯度消失一般出现在sigmoid上，因为sigmoid函数导数是f'(x) = f(x)(1-f(x)) ∈ (0,1) ，DNN的反向传播是对偏导数逐层相乘，因此(0,1)一直相乘，接近为0时，则梯度消失。可用 Relu/tanh/残差结构进行改善梯度消失的问题，是神经网络深度加深的时候学习的效果也不会便差
* 梯度清零，将数据传入网络，计算损失值并将误差进行反向传播，再进行参数的优化更新，对每轮的loss值相加再除以训练集的长度则得到训练误差
* 进行验证模式的时候不记录梯度，将验证集图片传入网络进行正向传播，损失值相加再除以验证集的长度则得到验证误差，准确率相加求均质就是验证集的准确率。
4. 在pytorch中的预测过程：对输入的预测图片进行和训练过程中相同的转为张量的处理传入网络，得到输出张量的最大值并打印出对应的类别。
5. 将pth模型转为onnx模型
6. 在c++上进行部署：
* 对输入数据进行与处理：这个地方要和训练过程中对图片进行与处理的方式一样，只将图片转换为张量就可以了。
* 使用得到的onnx模型对输入的张量进行预测
* 对输出的数组进行sort排序，得到值最大的索引值，即为预测的类别

  
  
  

  
  














